// Generated by CoffeeScript 1.9.1
(function() {
  var AnyOptions, Argument, Command, Dict, DocoptExit, DocoptLanguageError, Either, OneOrMore, Option, Optional, Pattern, Required, TokenStream, docopt, extras, formal_usage, parse_args, parse_atom, parse_doc_options, parse_expr, parse_long, parse_pattern, parse_seq, parse_shorts, print, printable_usage,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  print = function() {
    return console.log([].join.call(arguments, ' '));
  };

  DocoptLanguageError = (function(superClass) {
    extend(DocoptLanguageError, superClass);

    function DocoptLanguageError(message1) {
      this.message = message1;
      print(this.message);
    }

    return DocoptLanguageError;

  })(Error);

  DocoptExit = (function(superClass) {
    extend(DocoptExit, superClass);

    function DocoptExit(message) {
      DocoptExit.__super__.constructor.call(this, message);
      if (message) {
        print(message);
      }
      process.exit(1);
    }

    return DocoptExit;

  })(Error);

  Pattern = (function() {
    function Pattern(children1) {
      this.children = children1 != null ? children1 : [];
    }

    Pattern.prototype.valueOf = Pattern.toString;

    Pattern.prototype.toString = function() {
      var formals;
      formals = this.children.join(', ');
      return this.constructor.name + "(" + formals + ")";
    };

    Pattern.prototype.match = function() {
      throw new Error("classes inheriting from Pattern\nmust overload the match method");
    };

    Pattern.prototype.flat = function() {
      var child, j, len, ref, res;
      if (!this.hasOwnProperty('children')) {
        return [this];
      }
      res = [];
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        res = res.concat(child.flat());
      }
      return res;
    };

    Pattern.prototype.fix = function() {
      this.fix_identities();
      this.fix_list_arguments();
      return this.fix_list_options();
    };

    Pattern.prototype.fix_identities = function(uniq) {
      var c, enumerate, flat, i, j, k, len, len1, n, ref, ref1;
      if (uniq == null) {
        uniq = null;
      }
      "Make pattern-tree tips point to same object if they are equal.";
      if (!this.hasOwnProperty('children')) {
        return this;
      }
      if (uniq === null) {
        ref = [{}, this.flat()], uniq = ref[0], flat = ref[1];
        for (j = 0, len = flat.length; j < len; j++) {
          k = flat[j];
          uniq[k] = k;
        }
      }
      i = 0;
      enumerate = (function() {
        var len1, n, ref1, results;
        ref1 = this.children;
        results = [];
        for (n = 0, len1 = ref1.length; n < len1; n++) {
          c = ref1[n];
          results.push([i++, c]);
        }
        return results;
      }).call(this);
      for (n = 0, len1 = enumerate.length; n < len1; n++) {
        ref1 = enumerate[n], i = ref1[0], c = ref1[1];
        if (!c.hasOwnProperty('children')) {
          this.children[i] = uniq[c];
        } else {
          c.fix_identities(uniq);
        }
      }
      return this;
    };

    Pattern.prototype.fix_list_arguments = function() {
      "Find arguments that should accumulate values and fix them.";
      var c, child, counts, e, either, j, len, len1, len2, n, q, ref;
      either = (function() {
        var j, len, ref, results;
        ref = this.either().children;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          results.push(c.children);
        }
        return results;
      }).call(this);
      for (j = 0, len = either.length; j < len; j++) {
        child = either[j];
        counts = {};
        for (n = 0, len1 = child.length; n < len1; n++) {
          c = child[n];
          counts[c] = ((ref = counts[c]) != null ? ref : 0) + 1;
        }
        for (q = 0, len2 = child.length; q < len2; q++) {
          e = child[q];
          if (counts[e] > 1 && e.constructor === Argument) {
            e.value = [];
          }
        }
      }
      return this;
    };

    Pattern.prototype.fix_list_options = function() {
      "Find options that should accumulate values and fix them.";
      var c, child, counts, e, either, j, len, len1, len2, n, q, ref;
      either = (function() {
        var j, len, ref, results;
        ref = this.either().children;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          results.push(c.children);
        }
        return results;
      }).call(this);
      for (j = 0, len = either.length; j < len; j++) {
        child = either[j];
        counts = {};
        for (n = 0, len1 = child.length; n < len1; n++) {
          c = child[n];
          counts[c] = ((ref = counts[c]) != null ? ref : 0) + 1;
        }
        for (q = 0, len2 = child.length; q < len2; q++) {
          e = child[q];
          if (counts[e] > 1 && e.constructor === Option) {
            e.value = [];
          }
        }
      }
      return this;
    };

    Pattern.prototype.either = function() {
      var c, children, e, either, group, groups, i, indices, j, len, len1, n, name, oneormore, optional, ref, ref1, ref2, required, ret, types, zip;
      if (!this.hasOwnProperty('children')) {
        return new Either([new Required([this])]);
      } else {
        ret = [];
        groups = [[this]];
        while (groups.length) {
          children = groups.shift();
          ref = [0, {}, {}], i = ref[0], indices = ref[1], types = ref[2];
          zip = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = children.length; j < len; j++) {
              c = children[j];
              results.push([i++, c]);
            }
            return results;
          })();
          for (j = 0, len = zip.length; j < len; j++) {
            ref1 = zip[j], i = ref1[0], c = ref1[1];
            name = c.constructor.name;
            if (!(name in types)) {
              types[name] = [];
            }
            types[name].push(c);
            if (!(c in indices)) {
              indices[c] = i;
            }
          }
          if (either = types[Either.name]) {
            either = either[0];
            children.splice(indices[either], 1);
            ref2 = either.children;
            for (n = 0, len1 = ref2.length; n < len1; n++) {
              c = ref2[n];
              group = [c].concat(children);
              groups.push(group);
            }
          } else if (required = types[Required.name]) {
            required = required[0];
            children.splice(indices[required], 1);
            group = required.children.concat(children);
            groups.push(group);
          } else if (optional = types[Optional.name]) {
            optional = optional[0];
            children.splice(indices[optional], 1);
            group = optional.children.concat(children);
            groups.push(group);
          } else if (oneormore = types[OneOrMore.name]) {
            oneormore = oneormore[0];
            children.splice(indices[oneormore], 1);
            group = oneormore.children;
            group = group.concat(group, children);
            groups.push(group);
          } else {
            ret.push(children);
          }
        }
        return new Either((function() {
          var len2, q, results;
          results = [];
          for (q = 0, len2 = ret.length; q < len2; q++) {
            e = ret[q];
            results.push(new Required(e));
          }
          return results;
        })());
      }
    };

    return Pattern;

  })();

  Argument = (function(superClass) {
    extend(Argument, superClass);

    function Argument(argname, value1) {
      this.argname = argname;
      this.value = value1 != null ? value1 : null;
    }

    Argument.prototype.name = function() {
      return this.argname;
    };

    Argument.prototype.toString = function() {
      return "Argument(" + this.argname + ", " + this.value + ")";
    };

    Argument.prototype.match = function(left, collected) {
      var a, args, idx, l, same_name;
      if (collected == null) {
        collected = [];
      }
      args = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = left.length; j < len; j++) {
          l = left[j];
          if (l.constructor === Argument) {
            results.push(l);
          }
        }
        return results;
      })();
      if (!args.length) {
        return [false, left, collected];
      }
      idx = left.indexOf(args[0]);
      left = left.slice(0, idx).concat(left.slice(idx + 1));
      if (this.value === null || this.value.constructor !== Array) {
        collected = collected.concat([new Argument(this.name(), args[0].value)]);
        return [true, left, collected];
      }
      same_name = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = collected.length; j < len; j++) {
          a = collected[j];
          if (a.constructor === Argument && a.name() === this.name()) {
            results.push(a);
          }
        }
        return results;
      }).call(this);
      if (same_name.length > 0) {
        same_name[0].value.push(args[0].value);
        return [true, left, collected];
      } else {
        collected = collected.concat([new Argument(this.name(), [args[0].value])]);
        return [true, left, collected];
      }
    };

    return Argument;

  })(Pattern);

  Command = (function(superClass) {
    extend(Command, superClass);

    function Command(cmdname, value1) {
      this.cmdname = cmdname;
      this.value = value1 != null ? value1 : false;
    }

    Command.prototype.name = function() {
      return this.cmdname;
    };

    Command.prototype.toString = function() {
      return "Command(" + this.cmdname + ", " + this.value + ")";
    };

    Command.prototype.match = function(left, collected) {
      var args, l;
      if (collected == null) {
        collected = [];
      }
      args = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = left.length; j < len; j++) {
          l = left[j];
          if (l.constructor === Argument) {
            results.push(l);
          }
        }
        return results;
      })();
      if (!args.length || args[0].value !== this.name()) {
        return [false, left, collected];
      }
      left.splice(left.indexOf(args[0]), 1);
      collected.push(new Command(this.name(), true));
      return [true, left, collected];
    };

    return Command;

  })(Pattern);

  Option = (function(superClass) {
    extend(Option, superClass);

    function Option(short1, long1, argcount1, value1) {
      this.short = short1 != null ? short1 : null;
      this.long = long1 != null ? long1 : null;
      this.argcount = argcount1 != null ? argcount1 : 0;
      this.value = value1 != null ? value1 : false;
    }

    Option.prototype.toString = function() {
      return "Option(" + this.short + ", " + this.long + ", " + this.argcount + ", " + this.value + ")";
    };

    Option.prototype.name = function() {
      return this.long || this.short;
    };

    Option.parse = function(description) {
      var _, argcount, j, len, long, matched, options, ref, ref1, ref2, ref3, s, short, value;
      description = description.replace(/^\s*|\s*$/g, '');
      ref1 = (ref = description.match(/(.*?)  (.*)/)) != null ? ref : [null, description, ''], _ = ref1[0], options = ref1[1], description = ref1[2];
      options = options.replace(/,|=/g, ' ');
      ref2 = [null, null, 0, false], short = ref2[0], long = ref2[1], argcount = ref2[2], value = ref2[3];
      ref3 = options.split(/\s+/);
      for (j = 0, len = ref3.length; j < len; j++) {
        s = ref3[j];
        if (s.slice(0, 2) === '--') {
          long = s;
        } else if (s[0] === '-') {
          short = s;
        } else {
          argcount = 1;
        }
      }
      if (argcount === 1) {
        matched = /\[default:\s+(.*)\]/.exec(description);
        value = matched ? matched[1] : false;
      }
      return new Option(short, long, argcount, value);
    };

    Option.prototype.match = function(left, collected) {
      var j, l, left_, len, values;
      if (collected == null) {
        collected = [];
      }
      left_ = [];
      values = [];
      for (j = 0, len = left.length; j < len; j++) {
        l = left[j];
        if (l.constructor === Option && this.short === l.short && this.long === l.long) {
          values.push(l.value);
        } else {
          left_.push(l);
        }
      }
      if (this.value.constructor === Array) {
        this.value = this.value.concat(values);
        collected.push(this);
      }
      return [left.join(', ') !== left_.join(', '), left_, collected];
    };

    return Option;

  })(Pattern);

  AnyOptions = (function(superClass) {
    extend(AnyOptions, superClass);

    function AnyOptions() {
      return AnyOptions.__super__.constructor.apply(this, arguments);
    }

    AnyOptions.prototype.match = function(left, collected) {
      var l, left_;
      if (collected == null) {
        collected = [];
      }
      left_ = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = left.length; j < len; j++) {
          l = left[j];
          if (l.constructor !== Option) {
            results.push(l);
          }
        }
        return results;
      })();
      return [left.join(', ') !== left_.join(', '), left_, collected];
    };

    return AnyOptions;

  })(Pattern);

  Required = (function(superClass) {
    extend(Required, superClass);

    function Required() {
      return Required.__super__.constructor.apply(this, arguments);
    }

    Required.prototype.match = function(left, collected) {
      var c, j, l, len, matched, p, ref, ref1;
      if (collected == null) {
        collected = [];
      }
      l = left;
      c = collected;
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        ref1 = p.match(l, c), matched = ref1[0], l = ref1[1], c = ref1[2];
        if (!matched) {
          return [false, left, collected];
        }
      }
      return [true, l, c];
    };

    return Required;

  })(Pattern);

  Optional = (function(superClass) {
    extend(Optional, superClass);

    function Optional() {
      return Optional.__super__.constructor.apply(this, arguments);
    }

    Optional.prototype.match = function(left, collected) {
      var j, len, m, p, ref, ref1;
      if (collected == null) {
        collected = [];
      }
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        ref1 = p.match(left, collected), m = ref1[0], left = ref1[1], collected = ref1[2];
      }
      return [true, left, collected];
    };

    return Optional;

  })(Pattern);

  OneOrMore = (function(superClass) {
    extend(OneOrMore, superClass);

    function OneOrMore() {
      return OneOrMore.__super__.constructor.apply(this, arguments);
    }

    OneOrMore.prototype.match = function(left, collected) {
      var c, l, l_, matched, ref, times;
      if (collected == null) {
        collected = [];
      }
      l = left;
      c = collected;
      l_ = [];
      matched = true;
      times = 0;
      while (matched) {
        ref = this.children[0].match(l, c), matched = ref[0], l = ref[1], c = ref[2];
        times += matched ? 1 : 0;
        if (l_.join(', ') === l.join(', ')) {
          break;
        }
        l_ = l;
      }
      if (times >= 1) {
        return [true, l, c];
      }
      return [false, left, collected];
    };

    return OneOrMore;

  })(Pattern);

  Either = (function(superClass) {
    extend(Either, superClass);

    function Either() {
      return Either.__super__.constructor.apply(this, arguments);
    }

    Either.prototype.match = function(left, collected) {
      var j, len, outcome, outcomes, p, ref;
      if (collected == null) {
        collected = [];
      }
      outcomes = [];
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        outcome = p.match(left, collected);
        if (outcome[0]) {
          outcomes.push(outcome);
        }
      }
      if (outcomes.length > 0) {
        outcomes.sort(function(a, b) {
          if (a[1].length > b[1].length) {
            return 1;
          } else if (a[1].length < b[1].length) {
            return -1;
          } else {
            return 0;
          }
        });
        return outcomes[0];
      }
      return [false, left, collected];
    };

    return Either;

  })(Pattern);

  TokenStream = (function(superClass) {
    extend(TokenStream, superClass);

    function TokenStream(source, error) {
      var stream;
      this.error = error;
      stream = source.constructor === String ? source.replace(/^\s+|\s+$/, '').split(/\s+/) : source;
      this.push.apply(this, stream);
    }

    TokenStream.prototype.shift = function() {
      return [].shift.apply(this) || null;
    };

    TokenStream.prototype.current = function() {
      return this[0] || null;
    };

    TokenStream.prototype.toString = function() {
      return ([].slice.apply(this)).toString();
    };

    TokenStream.prototype.join = function(glue) {
      return [].join.apply(this, glue);
    };

    return TokenStream;

  })(Array);

  parse_shorts = function(tokens, options) {
    var o, opt, parsed, raw, ref, value;
    raw = tokens.shift().slice(1);
    parsed = [];
    while (raw.length > 0) {
      opt = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = options.length; j < len; j++) {
          o = options[j];
          if (o.short !== null && o.short[1] === raw[0]) {
            results.push(o);
          }
        }
        return results;
      })();
      if (opt.length > 1) {
        tokens.error("-" + raw[0] + " is specified ambiguously " + opt.length + " times");
      }
      if (opt.length < 1) {
        if (tokens.error === DocoptExit) {
          throw new tokens.error("-" + raw[0] + " is not recognized");
        } else {
          o = new Option('-' + raw[0], null);
          options.push(o);
          parsed.push(o);
          raw = raw.slice(1);
          continue;
        }
      }
      o = opt[0];
      opt = new Option(o.short, o.long, o.argcount, o.value);
      raw = raw.slice(1);
      if (opt.argcount === 0) {
        value = true;
      } else {
        if (raw === '' || raw === null) {
          if (tokens.current() === null) {
            throw new tokens.error("-" + opt.short[0] + " requires argument");
          }
          raw = tokens.shift();
        }
        ref = [raw, ''], value = ref[0], raw = ref[1];
      }
      opt.value = value;
      parsed.push(opt);
    }
    return parsed;
  };

  parse_long = function(tokens, options) {
    var _, o, opt, raw, ref, ref1, value;
    ref1 = (ref = tokens.current().match(/(.*?)=(.*)/)) != null ? ref : [null, tokens.current(), ''], _ = ref1[0], raw = ref1[1], value = ref1[2];
    tokens.shift();
    value = value === '' ? null : value;
    opt = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = options.length; j < len; j++) {
        o = options[j];
        if (o.long && o.long.slice(0, raw.length) === raw) {
          results.push(o);
        }
      }
      return results;
    })();
    if (opt.length > 1) {
      throw new tokens.error(raw + " is specified ambiguously " + opt.length + " times");
    }
    if (opt.length < 1) {
      if (tokens.error === DocoptExit) {
        throw new tokens.error(raw + " is not recognized");
      } else {
        o = new Option(null, raw, +(!!value));
        options.push(o);
        return [o];
      }
    }
    o = opt[0];
    opt = new Option(o.short, o.long, o.argcount, o.value);
    if (opt.argcount === 1) {
      if (value === null) {
        if (tokens.current() === null) {
          tokens.error((opt.name()) + " requires argument");
        }
        value = tokens.shift();
      }
    } else if (value === !null) {
      tokens.error((opt.name()) + " must not have an argument");
    }
    opt.value = value || true;
    return [opt];
  };

  parse_pattern = function(source, options) {
    var result, tokens;
    tokens = new TokenStream(source.replace(/([\[\]\(\)\|]|\.\.\.)/g, ' $1 '), DocoptLanguageError);
    result = parse_expr(tokens, options);
    if (tokens.current() === !null) {
      raise(tokens.error('unexpected ending: ' + tokens.join(' ')));
    }
    return new Required(result);
  };

  parse_expr = function(tokens, options) {
    var result, seq;
    seq = parse_seq(tokens, options);
    if (tokens.current() !== '|') {
      return seq;
    }
    result = seq.length > 1 ? [new Required(seq)] : seq;
    while (tokens.current() === '|') {
      tokens.shift();
      seq = parse_seq(tokens, options);
      result = result.concat(seq.length > 1 ? [new Required(seq)] : seq);
    }
    if (result.length > 1) {
      return [new Either(result)];
    } else {
      return result;
    }
  };

  parse_seq = function(tokens, options) {
    var atom, ref, result;
    result = [];
    while ((ref = tokens.current()) !== null && ref !== ']' && ref !== ')' && ref !== '|') {
      atom = parse_atom(tokens, options);
      if (tokens.current() === '...') {
        atom = [new OneOrMore(atom)];
        tokens.shift();
      }
      result = result.concat(atom);
    }
    return result;
  };

  parse_atom = function(tokens, options) {
    var result, token;
    token = tokens.current();
    result = [];
    if (token === '(') {
      tokens.shift();
      result = [new Required(parse_expr(tokens, options))];
      if (tokens.shift() !== ')') {
        raise(tokens.error("Unmatched '('"));
      }
      return result;
    } else if (token === '[') {
      tokens.shift();
      if (tokens.current() === 'options') {
        result = [new Optional([new AnyOptions])];
        tokens.shift();
      } else {
        result = [new Optional(parse_expr(tokens, options))];
      }
      if (tokens.shift() !== ']') {
        raise(tokens.error("Unmatched '['"));
      }
      return result;
    } else if (token.slice(0, 2) === '--') {
      if (token === '--') {
        return [new Command(tokens.shift())];
      } else {
        return parse_long(tokens, options);
      }
    } else if (token[0] === '-' && token !== '-') {
      return parse_shorts(tokens, options);
    } else if ((token[0] === '<' && token[token.length - 1] === '>') || /^[^a-z]*[A-Z]+[^a-z]*$/.test(token)) {
      return [new Argument(tokens.shift())];
    } else {
      return [new Command(tokens.shift())];
    }
  };

  parse_args = function(source, options, options_first) {
    var long, opts, shorts, token, tokens;
    tokens = new TokenStream(source, DocoptExit);
    opts = [];
    while ((token = tokens.current()) !== null) {
      if (token === '--') {
        return opts.concat((function() {
          var results;
          results = [];
          while (tokens.length) {
            results.push(new Argument(null, tokens.shift()));
          }
          return results;
        })());
      } else if (token.slice(0, 2) === '--') {
        long = parse_long(tokens, options);
        opts = opts.concat(long);
      } else if (token[0] === '-' && token !== '-') {
        shorts = parse_shorts(tokens, options);
        opts = opts.concat(shorts);
      } else if (options_first) {
        return opts.concat((function() {
          var results;
          results = [];
          while (tokens.length) {
            results.push(new Argument(null, tokens.shift()));
          }
          return results;
        })());
      } else {
        opts.push(new Argument(null, tokens.shift()));
      }
    }
    return opts;
  };

  parse_doc_options = function(doc) {
    var j, len, ref, results, s;
    ref = doc.split(/^\s*-|\n\s*-/).slice(1);
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      s = ref[j];
      results.push(Option.parse('-' + s));
    }
    return results;
  };

  printable_usage = function(doc, name) {
    var usage_split;
    usage_split = doc.split(/(usage:)/i);
    if (usage_split.length < 3) {
      throw new DocoptLanguageError('"usage:" (case-insensitive) not found.');
    } else if (usage_split.length > 3) {
      throw new DocoptLanguageError('More than one "usage:" (case-insensitive).');
    }
    return usage_split.slice(1).join('').split(/\n\s*\n/)[0].replace(/^\s+|\s+$/, '');
  };

  formal_usage = function(printable_usage) {
    var pu, s;
    pu = printable_usage.split(/\s+/).slice(1);
    return ((function() {
      var j, len, ref, results;
      ref = pu.slice(1);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        s = ref[j];
        results.push(s === pu[0] ? '|' : s);
      }
      return results;
    })()).join(' ');
  };

  extras = function(help, version, options, doc) {
    var j, len, opt, opts;
    opts = {};
    for (j = 0, len = options.length; j < len; j++) {
      opt = options[j];
      if (opt.value) {
        opts[opt.name()] = true;
      }
    }
    if (help && (opts['--help'] || opts['-h'])) {
      print(doc.replace(/^\s*|\s*$/, ''));
      process.exit();
    }
    if (version && opts['--version']) {
      print(version);
      return process.exit();
    }
  };

  Dict = (function(superClass) {
    extend(Dict, superClass);

    function Dict(pairs) {
      var j, key, len, ref, value;
      for (j = 0, len = pairs.length; j < len; j++) {
        ref = pairs[j], key = ref[0], value = ref[1];
        this[key] = value;
      }
    }

    Dict.prototype.toString = function() {
      var atts, k;
      atts = (function() {
        var results;
        results = [];
        for (k in this) {
          if (k !== 'constructor' && k !== 'toString') {
            results.push(k);
          }
        }
        return results;
      }).call(this);
      atts.sort();
      return '{' + ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = atts.length; j < len; j++) {
          k = atts[j];
          results.push(k + ': ' + this[k]);
        }
        return results;
      }).call(this)).join(',\n ') + '}';
    };

    return Dict;

  })(Object);

  docopt = function(doc, kwargs) {
    var a, allowedargs, arg, argums, argv, formal_pattern, help, left, matched, name, opt, options, options_first, parameters, pot_arguments, pot_options, ref, usage, version;
    if (kwargs == null) {
      kwargs = {};
    }
    allowedargs = ['argv', 'name', 'help', 'version', 'options_first'];
    for (arg in kwargs) {
      if (indexOf.call(allowedargs, arg) < 0) {
        throw new Error("unrecognized argument to docopt: ");
      }
    }
    argv = kwargs.argv === void 0 ? process.argv.slice(2) : kwargs.argv;
    name = kwargs.name === void 0 ? null : kwargs.name;
    help = kwargs.help === void 0 ? true : kwargs.help;
    version = kwargs.version === void 0 ? null : kwargs.version;
    options_first = kwargs.options_first === void 0 ? false : kwargs.options_first;
    usage = printable_usage(doc, name);
    pot_options = parse_doc_options(doc);
    formal_pattern = parse_pattern(formal_usage(usage), pot_options);
    argv = parse_args(argv, pot_options, options_first);
    extras(help, version, argv, doc);
    ref = formal_pattern.fix().match(argv), matched = ref[0], left = ref[1], argums = ref[2];
    if (matched && left.length === 0) {
      options = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = argv.length; j < len; j++) {
          opt = argv[j];
          if (opt.constructor === Option) {
            results.push(opt);
          }
        }
        return results;
      })();
      pot_arguments = (function() {
        var j, len, ref1, ref2, results;
        ref1 = formal_pattern.flat();
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          a = ref1[j];
          if ((ref2 = a.constructor) === Argument || ref2 === Command) {
            results.push(a);
          }
        }
        return results;
      })();
      parameters = [].concat(pot_options, options, pot_arguments, argums);
      return new Dict((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = parameters.length; j < len; j++) {
          a = parameters[j];
          results.push([a.name(), a.value]);
        }
        return results;
      })());
    }
    throw new DocoptExit(usage);
  };

  module.exports = {
    docopt: docopt,
    Option: Option,
    Argument: Argument,
    Command: Command,
    Required: Required,
    AnyOptions: AnyOptions,
    Either: Either,
    Optional: Optional,
    Pattern: Pattern,
    OneOrMore: OneOrMore,
    TokenStream: TokenStream,
    Dict: Dict,
    formal_usage: formal_usage,
    parse_doc_options: parse_doc_options,
    parse_pattern: parse_pattern,
    parse_long: parse_long,
    parse_shorts: parse_shorts,
    parse_args: parse_args,
    printable_usage: printable_usage
  };

}).call(this);
